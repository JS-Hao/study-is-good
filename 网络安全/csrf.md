# CSRF

## 定义

CSRF (Cross-site request forgery) 跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击者的网站发起跨站请求，利用受害者在被攻击网站已获取的注册凭证（一般即为 cookie），绕过后台用户验证，达到冒充用户对被攻击网站执行某项操作的目的

## 常见攻击类型

- get 类型的 csrf
  受害者访问第三方网站后，网站随即发起的 get 请求，一般是包含 img 的页面，如
  ```html
  <img src="http://bank.example/withdraw?amount=10000&for=hacker" />
  ```
- post 类型的 csrf
  受害者访问第三方网站后，网站随即发起的 post 请求，一般是可自动提交表单的页面，完成一次 post 操作

- 链接类型的 csrf

## 特点

- 攻击一般发起于第三方网站，而不是被攻击网站；
- 攻击者无法直接获取用户在被攻击网站的登录凭证，仅仅只能“冒用”
- 由于攻击者无法获取用户的登录凭证，所以做不到窃取的效果，只能冒充受害者提交操作；
- 跨站请求的方式众多：图片 URL、超链接、CORS、FROM 提交等等，甚至可以嵌入到第三方论坛的图片、文章中，难以查找

## 防范手段

- 同源检测
  借助请求 header 中携带的 origin 和 referer ，判定请求的域名来源，但此方案并不靠谱，由于浏览器兼容问题、及不同的实现机制，以及最新的协议制定，请求可能不携带这些 header 头信息（甚至暗改）

- 使用 CSRF token

  1. 每当用户访问网站时，后台提供给前端一个 token（并不放在 cookie，防止被冒用）
  2. 页面提交的请求会携带此 token
  3. 服务端验证 token 是否正确
     此方案可谓是最严格、安全的方案了，但问题是 token 放在哪儿比较合适？以及前端发起请求时，如果才能每次都携带这个 token 呢？是否有通用的解决方案？

- 使用双重 cookie 验证

  - 由于攻击者无法直接获取 cookie，因此后台可将特定的 cookie key 作为校验字段；
  - 前端发起请求时，不仅在 cookie 中携带此字段，而且还需将此字段添加到请求参数中；
  - 后台判定 cookie 及 请求参数中是否均存在此 key，且校验其一致性
    此方案相对比较简单，但问题在于，为确保不同子域下的登录信息统一，只能将 key 放在母域下，这意味着任何子域均可修改它，一旦某一子域被攻击（如使用 XSS），篡改了 key, 这样攻击者就能知道 key 了

- samesite cookie

  - google 起草了草案改进 http 协议，在 setCookie 时，可以添加 samesite 属性，不同值的效果不同：
  - Samesite=Strict 严格模式，在跨域请求时，绝不会携带设为此值的 cookie 字段，除非同源，比如在 a.com 发起任何 b.com 的请求，都不携带
  - Samesite=Lax 宽松模式，假设这个请求是打开新页面或链接跳转页，且为 get 请求，则允许携带此字段，比如在 a.com 链接里打开 b.com 链接，是可携带的，但如果是 a.com 里发起 b.com 的 ajax 请求，则被拒绝

  使用 samesite，那么即使受害者进入到了第三方页面，向被攻击网站发起请求，也不会携带 cookie，但问题是当前的 samesite 需要高版本浏览器才支持，是未来的可替代方案

## 关于 302 重定向导致 origin 丢失的原因分析

_在 302 重定向之后 Origin 不包含在重定向的请求中，因为 Origin 可能会被认为是其他来源的敏感信息。对于 302 重定向的情况来说都是定向到新的服务器上的 URL，因此浏览器不想将 Origin 泄漏到新的服务器上。_

## egg.js 中的 csrf 放在哪儿的呢？如何做到每次前端发起请求，后台都会对 csrf 进行校验？
