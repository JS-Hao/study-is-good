# XSS

## 如果我要使用 XSS 攻击一个网站，有哪些途径？

**场景： 有些网站的内容是根据用户输入内容呈现的（如：在输入框输入内容 --> url 带参数跳转 --> 根据参数内容渲染模板，显示页面**

### 借助内容提前闭合标签，并生成新的 script 标签执行攻击脚本

攻：

```js
<input value="<%=data %>">

data = " /><script>alert('xss')</script>
```

守：转义之！

```
<input value="<%=escapeHTML(data) >">
```

### 借助标签内的 `javascript:` 特性，只要你点击了就完蛋了!😈

```
<a herf="<%= url %>">跳转</a>

url = javascript:alert('xss!');
```

守：不怕，搞白名单！😏

```
const whiteList = ['https://www.baidu.com', 'https://wow.blizzard.cn']
const isValid = url => whiteList.includes(url);

if (isValid(url)) {
  return <a herf="<%= url %>">跳转</a>
} else {
  <a herf="/404">跳转</a>
}
```

## XSS 攻击手段总结：

- 在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。
- 在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。
- 在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。
- 在标签的 href、src 等属性中，包含 javascript: 等可执行代码。
- 在 onload、onerror、onclick 等事件中，注入不受控制代码。
- 在 style 属性和标签中，包含类似 background-image:url("javascript:..."); 的代码（新版本浏览器已经可以防范）。
- 在 style 属性和标签中，包含类似 expression(...) 的 CSS 表达式代码（新版本浏览器已经可以防范）。

## XSS 分类

XSS 攻击共分为存储型、反射型、DOM 型三大类

### 存储型 XSS

攻击步骤：

1. 攻击者在网站上提交自己的恶意代码，存储到后台的数据库中；
2. 用户访问此网站，在特定场景下会拉取这段恶意代码，最终插入到页面中；
3. 浏览器解析、执行恶意代码（更有高级玩法是：此恶意代码加载更为复杂的恶意脚本）
4. 恶意代码将用户的信息（如 cookie） 发送给攻击者，或在页面上模拟用户执行一系列操作
5. 一般发生上述场景的网站：如论坛评论、商品评论

### 反射型 XSS

1. 攻击者在 URL 上添加了恶意代码的参数；
2. 用户打开此 URL（所以一般陌生人发给你的奇怪链接千万要谨慎），恶意代码参数被插入到页面中；
3. 后面步骤同 存储型 XSS

可见 反射型与存储型最大的不同是存储的地方不一样，其余是类似的，反射型一般发生在 网站搜索、跳转等场景

### DOM 型 XSS

1. 攻击者制造特殊的 URL，携带恶意代码
2. 用户打开链接后，前端 js 取出 url 中的恶意代码并执行
3. 同上

可见，DOM 型 XSS 与存储型、反射型最大的不同在于：前者的插入点是 js，属于前端 js 自身的安全漏洞，而后两者因为是通过服务端渲染 html 的， 属于服务端的安全漏洞

## XSS 攻击防范

### 输入过滤是否可行？

输入过滤存在两种方式：前端过滤 or 后端过滤，对于前者而言不可行，因为攻击者可伪造请求绕过前端，直接向后端提交数据，而对于后端过滤，虽可防范大部分 XSS 攻击，但存在以下问题：在内容提交阶段，无法确定它的最终输出在哪里 —— 比如一个网站存在多端（网页版、APP），而用户在网页版输入内容后进行过滤，并将过滤后的内容存储在数据库，则在下次呈现时，若以浏览器打开，则可识别编码并转义成原本的内容，而对于不识别其编码的 APP 而言，则变成了一堆乱码；其外，前端不同地方的编码方式也不一样，难以做到“大一统”，因此输入端过滤容易引入乱码、内容不稳定的问题，最好的做法是输出端过滤

### 预防存储型及反射型

- 对 HTML 进行充分转义
- 改为纯前端渲染 —— 将数据与模板分离
  服务端渲染 html 时，是以数据拼接到模板中的方式进行的，浏览器难以识别拼接后的 html 内容的真伪度，只能乖乖解析，而改为纯前端渲染后，前端通过 ajax 获取数据，并以诸如 innerText、setAttribute 等 API 的方式告诉浏览器“这是文本”、“这是属性”，因此浏览器不会轻易受骗

### 预防 DOM 型

DOM 型 XSS 攻击，主要是前端 js 编写不严谨，把不可信任的数据当代码执行了，要小心如下几个场景：

1. 提防 innerHTML、outerHTML、document.write 的使用，不要将不可信数据插入到页面中；
2. 提防能直接将字符串当代码运行的 API，如 eval、setTimeout、setInterval 及 DOM 内联事件监听器等

### 其他有效的防范措施

1. 使用 CSP
2. 控制输入长度
3. 使用 http-only 技术，防止 cookies 被盗取

先有很多知名的 XSS 自动检测工具，帮助你已上线的应用检测防范 XSS 攻击的完善程度

### encodeURI / decodeURI / encodeURIComponent / decodeURIComponent 的作用与区别

1. 作用：URI 中存在保留字，如`: / & ?`等，如果本身 URI 参数中就携带部分保留字，就会对浏览器产生歧义，为了避免歧义，就需要编码，使这些特殊字符变成普通文本，这也是这些 API 的任务所在
2. encodeURI 是用于对整个 URI 进行编码，并不会对诸如 `: / & ?`进行转义，但会对类似空格等特殊字符进行转义；
3. encodeURIComponent 则是对 URI 组件进行转义，比如上述提到的参数含有特殊保留字，则可以使用它进行转义

### CSP (Content Security Policy) 是个啥？

简单来说，CSP 一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本攻击（XSS）及数据注入攻击等，它通过告诉浏览器一系列规则，严格指定页面中的哪些资源允许有哪些来源，不在指定范围的统统拒绝。其施展途径有：

- 在 meta 标签设置 csp 属性，
- 在响应头中设置（在响应头设置能具备更全的功能）

例如以下设置，对所有 fetch 方式的链接，仅允许同域名下的资源通过

参考[Content Security Policy (CSP) 介绍](https://juejin.im/entry/6844903665224908807)

```html
<meta http-equiv="Content-Security-Policy" content="default-src 'self'" />
```

### 了解下 HTTP-only

### 哪些请求能跨域？哪些不能？

列举: ajax 请求，图片，脚本，表单提交

## 阅读清单

- [ajax 跨域，这应该是最全的解决方案了](https://segmentfault.com/a/1190000012469713)
