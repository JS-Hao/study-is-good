# 数据结构与算法

## 复杂度分析

- 分析时间复杂度常用三大方法

  1. 只关注循环执行次数最多的那一行代码
  2. 加法原则：总复杂度等于量级最大的那段代码的复杂度
  3. 乘法原则：嵌套代码的复杂度，等于嵌套内外代码复杂度的乘积
     比如：
     ```javascript
     for (let i = 0; i < n; i++) {
       for (let j = 0; j < n; j++) {
         i * j;
       }
     }
     ```
     很显然复杂度等于 n \* n = O(n^2)

- 常见的时间复杂度
  1. 常熟阶 O(1)
  2. 对数阶 O(logN)
  3. 线性阶 O(n)
  4. 线性对数阶 O(nlogN)
  5. 平方阶、立方阶、k 方阶... O(n^k)
  6. 指数阶 O(2^n)
  7. 阶乘阶 O(n!)

其中 6、7 不常用，时间复杂度为它们的问题一般叫 NP 问题

- 空间复杂度与时间类似，比较简单，平时主要关注数组即可

- 最好、最坏、平均时间复杂度

  - 对于同一代码，在不同输入情况下，复杂度量级可能是不一样的，因此有时候需要分情况考虑；
  - 平均时间复杂度，一般是指该算法的所有情况加权后的复杂度，也称期望时间复杂度，它 = (每种情况下的复杂度 \* 出现概率) 之和 / 所有情况数量

- 均摊时间复杂度与摊还分析
  - 均摊时间复杂度是一种比较特殊的平均时间复杂度，平时接触不会很多，可以大概看下定义
    _对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。以上的分析方式叫摊还分析，计算出的结果为均摊时间复杂度_

## 数组和链表的对比

- 内存分配方式不同：由于数组具有连续性，需要开辟一段连续的内存空间（前提是系统得有足够的连续内存供使用，因此要求比较高），而链表则可充分利用离散的内存，根据指针“串联”起来，灵活度更高，但相比数组更占内存空间；
- 时间复杂度不同：插入、删除等操作，数组为保证连续性，为 O(n)，而链表则为 O(1)，随机访问操作，数组只需 O(1)，而链表需要 O(n)

## 排序算法汇总

- 在实际排序中，由于排序的元素数量规模是比较小的，因此在比较同一复杂度的算法时，常熟、系数、低阶也应该考虑进去
- 稳定的排序算法：当被排序的元素中出现值相等的元素，在排序前后它们的顺序依旧保持不变，则为稳定的排序算法，否则则为不稳定的排序算法
- 原地排序：特指空间复杂度为 O(1) 的算法，一般情况下，原地排序都是在原数组中进行的，无须新增额外的数组内存开销
- 为什么冒泡与插入排序的复杂度相同，但插入更热门？因为在代码实现层面（主要是元素交换）上插入更简答，占用代码行数更少，在实际运行中还是要快于冒泡的

| 排序算法 | 是原地排序？ | 稳定性 | 最好时间复杂度 | 最坏时间复杂度 | 平均复杂度 |
| 冒泡排序 | 是 | 稳定 | O(n) | O(n^2) | O(n^2)) |
| 插入排序 | 是 | 稳定 | O(n) | O(n^2) | O(n^2)) |
| 选择排序 | 是 | 不稳定 | O(n^2) | O(n^2) | O(n^2)) |
